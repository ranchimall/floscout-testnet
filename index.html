<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>FLO Scout</title>
	<link rel="stylesheet" href="css/main.min.css" />
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
	<script src="https://unpkg.com/uhtml@3.0.1/es.js"></script>
	<script src="scripts/components.min.js"></script>
	<script src="scripts/flexsearch.light.js" defer></script>
	<script src="scripts/lib.js" defer></script>
	<script src="scripts/floCrypto.js" defer></script>
	<script src="scripts/floBlockchainAPI.js" defer></script>
	<script src="scripts/floTokenAPI.js" defer></script>
	<link rel="shortcut icon" href="floscout.svg" type="image/x-icon">
</head>

<body class="hidden">
	<sm-notifications id="notification_drawer"></sm-notifications>
	<div id="loading">
		<sm-spinner></sm-spinner>
		<h4>Loading RanchiMall FLO Scout</h4>
	</div>
	<header id="main_header" class="margin">
		<a href="#/home" id="logo" class="app-brand hide-on-small">
			<svg id="main_logo" class="icon" viewBox="0 0 27.25 32">
				<title>RanchiMall</title>
				<path
					d="M27.14,30.86c-.74-2.48-3-4.36-8.25-6.94a20,20,0,0,1-4.2-2.49,6,6,0,0,1-1.25-1.67,4,4,0,0,1,0-2.26c.37-1.08.79-1.57,3.89-4.55a11.66,11.66,0,0,0,3.34-4.67,6.54,6.54,0,0,0,.05-2.82C20,3.6,18.58,2,16.16.49c-.89-.56-1.29-.64-1.3-.24a3,3,0,0,1-.3.72l-.3.55L13.42.94C13,.62,12.4.26,12.19.15c-.4-.2-.73-.18-.72.05a9.39,9.39,0,0,1-.61,1.33s-.14,0-.27-.13C8.76.09,8-.27,8,.23A11.73,11.73,0,0,1,6.76,2.6C4.81,5.87,2.83,7.49.77,7.49c-.89,0-.88,0-.61,1,.22.85.33.92,1.09.69A5.29,5.29,0,0,0,3,8.33c.23-.17.45-.29.49-.26a2,2,0,0,1,.22.63A1.31,1.31,0,0,0,4,9.34a5.62,5.62,0,0,0,2.27-.87L7,8l.13.55c.19.74.32.82,1,.65a7.06,7.06,0,0,0,3.46-2.47l.6-.71-.06.64c-.17,1.63-1.3,3.42-3.39,5.42L6.73,14c-3.21,3.06-3,5.59.6,8a46.77,46.77,0,0,0,4.6,2.41c.28.13,1,.52,1.59.87,3.31,2,4.95,3.92,4.95,5.93a2.49,2.49,0,0,0,.07.77h0c.09.09,0,.1.9-.14a2.61,2.61,0,0,0,.83-.32,3.69,3.69,0,0,0-.55-1.83A11.14,11.14,0,0,0,17,26.81a35.7,35.7,0,0,0-5.1-2.91C9.37,22.64,8.38,22,7.52,21.17a3.53,3.53,0,0,1-1.18-2.48c0-1.38.71-2.58,2.5-4.23,2.84-2.6,3.92-3.91,4.67-5.65a3.64,3.64,0,0,0,.42-2A3.37,3.37,0,0,0,13.61,5l-.32-.74.29-.48c.17-.27.37-.63.46-.8l.15-.3.44.64a5.92,5.92,0,0,1,1,2.81,5.86,5.86,0,0,1-.42,1.94c0,.12-.12.3-.15.4a9.49,9.49,0,0,1-.67,1.1,28,28,0,0,1-4,4.29C8.62,15.49,8.05,16.44,8,17.78a3.28,3.28,0,0,0,1.11,2.76c.95,1,2.07,1.74,5.25,3.32,3.64,1.82,5.22,2.9,6.41,4.38A4.78,4.78,0,0,1,21.94,31a3.21,3.21,0,0,0,.14.92,1.06,1.06,0,0,0,.43-.05l.83-.22.46-.12-.06-.46c-.21-1.53-1.62-3.25-3.94-4.8a37.57,37.57,0,0,0-5.22-2.82A13.36,13.36,0,0,1,11,21.19a3.36,3.36,0,0,1-.8-4.19c.41-.85.83-1.31,3.77-4.15,2.39-2.31,3.43-4.13,3.43-6a5.85,5.85,0,0,0-2.08-4.29c-.23-.21-.44-.43-.65-.65A2.5,2.5,0,0,1,15.27.69a10.6,10.6,0,0,1,2.91,2.78A4.16,4.16,0,0,1,19,6.16a4.91,4.91,0,0,1-.87,3c-.71,1.22-1.26,1.82-4.27,4.67a9.47,9.47,0,0,0-2.07,2.6,2.76,2.76,0,0,0-.33,1.54,2.76,2.76,0,0,0,.29,1.47c.57,1.21,2.23,2.55,4.65,3.73a32.41,32.41,0,0,1,5.82,3.24c2.16,1.6,3.2,3.16,3.2,4.8a1.94,1.94,0,0,0,.09.76,4.54,4.54,0,0,0,1.66-.4C27.29,31.42,27.29,31.37,27.14,30.86ZM6.1,7h0a3.77,3.77,0,0,1-1.46.45L4,7.51l.68-.83a25.09,25.09,0,0,0,3-4.82A12,12,0,0,1,8.28.76c.11-.12.77.32,1.53,1l.63.58-.57.84A10.34,10.34,0,0,1,6.1,7Zm5.71-1.78A9.77,9.77,0,0,1,9.24,7.18h0a5.25,5.25,0,0,1-1.17.28l-.58,0,.65-.78a21.29,21.29,0,0,0,2.1-3.12c.22-.41.42-.76.44-.79s.5.43.9,1.24L12,5ZM13.41,3a2.84,2.84,0,0,1-.45.64,11,11,0,0,1-.9-.91l-.84-.9.19-.45c.34-.79.39-.8,1-.31A9.4,9.4,0,0,1,13.8,2.33q-.18.34-.39.69Z" />
			</svg>
			<div class="app-name">
				<div class="app-name__company">RanchiMall</div>
				<h4 class="app-name__title">
					FLO Scout
				</h4>
			</div>
		</a>
		<div id="search_wrapper">
			<sm-input id='main_search_field' type="search"
				placeholder="block, transactions, address, token or contract">
				<svg class="icon" slot="icon" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24"
					width="24px" fill="#000000">
					<path d="M0 0h24v24H0V0z" fill="none" />
					<path
						d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" />
				</svg>
			</sm-input>
			<ul id="suggestions"></ul>
		</div>
		<theme-toggle></theme-toggle>
	</header>
	<div id="page_header" class="flex margin">
		<button class="icon-only" onclick="history.back()">
			<svg class="icon" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"
				fill="#000000">
				<path d="M0 0h24v24H0V0z" fill="none" />
				<path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z" />
			</svg>
		</button>
		<h4 id="page_title"></h4>
	</div>
	<main id="page_container" class="flex flex-direction-column"></main>
	<sm-popup id="filter_s_c_popup">
		<header slot="header" class="popup__header">
			<button class="popup__header__close" onclick="closePopup()">
				<svg class="icon" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"
					fill="#000000">
					<path d="M0 0h24v24H0V0z" fill="none" />
					<path
						d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z" />
				</svg>
			</button>
			<h3>
				Filter by
			</h3>
		</header>
		<div id="filter_s_c_popup__content" class="grid gap-1-5"></div>
		<footer class="flex gap-0-5">
			<button class="button button--colored margin-left-auto" onclick="clearFilters()">
				Clear
			</button>
			<button class="button button--primary" onclick="renderSmartContracts()">
				Apply
			</button>
		</footer>
	</sm-popup>
	<!-- Set urls for token and flo Apis -->
	<script>
		const testMode = true
		const floGlobals = {
			blockchain: testMode ? "FLO_TEST" : "FLO",
			tokenApiUrl: testMode ? 'https://ranchimallflo-testnet-blockbook.ranchimall.net' : 'https://ranchimallflo.ranchimall.net',
			floApiUrl: testMode ? 'https://blockbook-testnet.ranchimall.net' : 'https://flosight.ranchimall.net',
		}
	</script>
	<script>
		/*jshint esversion: 8 */
		/**
		  * @yaireo/relative-time - javascript function to transform timestamp or date to local relative-time
		  *
		  * @version v1.0.0
		  * @homepage https://github.com/yairEO/relative-time
		  */
		!function (e, t) { var o = o || {}; "function" == typeof o && o.amd ? o([], t) : "object" == typeof exports && "object" == typeof module ? module.exports = t() : "object" == typeof exports ? exports.RelativeTime = t() : e.RelativeTime = t() }(this, (function () { const e = { year: 31536e6, month: 2628e6, day: 864e5, hour: 36e5, minute: 6e4, second: 1e3 }, t = "en", o = { numeric: "auto" }; function n(e) { e = { locale: (e = e || {}).locale || t, options: { ...o, ...e.options } }, this.rtf = new Intl.RelativeTimeFormat(e.locale, e.options) } return n.prototype = { from(t, o) { const n = t - (o || new Date); for (let t in e) if (Math.abs(n) > e[t] || "second" == t) return this.rtf.format(Math.round(n / e[t]), t) } }, n }));
		const relativeTime = new RelativeTime({ style: 'narrow' });
	</script>
	<script>
		"use strict";
		// Global variables
		const { html, render: renderElem } = uhtml;
		//Checks for internet connection status
		if (!navigator.onLine)
			floGlobals.connectionErrorNotification = notify('There seems to be a problem connecting to the internet, Please check you internet connection.', 'error')
		window.addEventListener('offline', () => {
			floGlobals.connectionErrorNotification = notify('There seems to be a problem connecting to the internet, Please check you internet connection.', 'error')
		})
		window.addEventListener('online', () => {
			getRef('notification_drawer').remove(floGlobals.connectionErrorNotification)
			notify('We are back online.', 'success')
		})
		//Function for displaying toast notifications. pass in error for mode param if you want to show an error.
		function notify(message, mode, options = {}) {
			let icon
			switch (mode) {
				case 'success':
					icon = `<svg class="icon icon--success" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path fill="none" d="M0 0h24v24H0z"/><path d="M10 15.172l9.192-9.193 1.415 1.414L10 18l-6.364-6.364 1.414-1.414z"/></svg>`
					break;
				case 'error':
					icon = `<svg class="icon icon--error" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10-4.477 10-10 10zm-1-7v2h2v-2h-2zm0-8v6h2V7h-2z"/></svg>`
					options.pinned = true
					break;
			}
			if (mode === 'error') {
				console.error(message)
			}
			return getRef("notification_drawer").push(message, { icon, ...options });
		}
		// Use instead of document.getElementById
		function getRef(elementId) {
			return document.getElementById(elementId);
		}

		// Use when a function needs to be executed after user finishes changes
		const debounce = (callback, wait) => {
			let timeoutId = null;
			return (...args) => {
				window.clearTimeout(timeoutId);
				timeoutId = window.setTimeout(() => {
					callback.apply(null, args);
				}, wait);
			};
		}

		function formatAmount(amount = 0, currency = 'inr') {
			if (!amount)
				return '0';
			return amount.toLocaleString(undefined, { currency, maximumFractionDigits: 8, minimumFractionDigits: 0 })
		}
		let zIndex = 10
		// function required for popups or modals to appear
		function openPopup(popupId, pinned) {
			zIndex++
			getRef(popupId).setAttribute('style', `z-index: ${zIndex}`)
			getRef(popupId).show({ pinned })
			return getRef(popupId);
		}

		// hides the popup or modal
		function closePopup() {
			if (popupStack.peek() === undefined)
				return;
			popupStack.peek().popup.hide()
		}
		document.addEventListener('popupopened', async e => {
			switch (e.target.id) {
				case 'filter_s_c_popup':
					function checkSelected(e) {
						const filterButton = e.target.closest('label')
						filterButton.classList.toggle('selected')
					}
					const scTypes = [['time-trigger', 'Timed Event'], ['external-trigger', 'External Trigger'], ['tokenswap', 'Token Swap']]
					const { tokens, types } = floGlobals.appliedFilters
					renderElem(getRef('filter_s_c_popup__content'), html`
						<div class="grid gap-1">
							<h5>Type</h5>
							<div id="type_filter_list" class="flex flex-wrap gap-0-5">
								${scTypes.map(([type, title]) => html`
									<label class=${`sc-filter sc-type-filter interact ${types.has(type) ? 'selected' : ''}`}>
										<input type="checkbox" name="sc-type-filter" value=${type} onchange=${checkSelected} ?checked=${types.has(type)}/>
										<span class="sc-filter__name">${title}</span>
									</label>
								`)}
							</div>
						</div>
						<div class="grid gap-1">
							<h5>Involved tokens</h5>
							<div id="token_filter_list" class="flex flex-wrap gap-0-5">
								${floGlobals.tokenList.map(token => html`
									<label class=${`sc-filter token-filter interact ${tokens.has(token) ? 'selected' : ''}`}>
										<input type="checkbox" name="token-filter" value=${token} onchange=${checkSelected} ?checked=${tokens.has(token)}/>
										<span class="sc-filter__name">${token}</span>
									</label>
								`)}
							</div>
						</div>
					`)
					break;
			}
		})
		document.addEventListener('popupclosed', e => {
			zIndex--
			switch (e.target.id) {
				case 'filter_s_c_popup':
					renderElem(getRef('filter_s_c_popup__content'), html``)
					break;
			}
		})
		// fetch data and return json
		async function fetchJson(url, options = {}) {
			const response = await fetch(url, options)
			const json = await response.json()
			if (response.ok) {
				return json
			} else {
				console.error(json)
				throw new Error(json.description)
			}
		}
		function getFormattedTime(timestamp, format) {
			try {
				timestamp = parseInt(timestamp)
				if (String(timestamp).length < 13)
					timestamp *= 1000
				let [day, month, date, year] = new Date(timestamp).toString().split(' '),
					minutes = new Date(timestamp).getMinutes(),
					hours = new Date(timestamp).getHours(),
					currentTime = new Date().toString().split(' ')

				minutes = minutes < 10 ? `0${minutes}` : minutes
				let finalHours = ``;
				if (hours > 12)
					finalHours = `${hours - 12}:${minutes}`
				else if (hours === 0)
					finalHours = `12:${minutes}`
				else
					finalHours = `${hours}:${minutes}`

				finalHours = hours >= 12 ? `${finalHours} PM` : `${finalHours} AM`
				switch (format) {
					case 'date-only':
						return `${month} ${date}, ${year}`;
						break;
					case 'time-only':
						return finalHours;
					case 'relative':
						return relativeTime.from(timestamp)
					default:
						return `${month} ${date}, ${year} at ${finalHours}`;
				}
			} catch (e) {
				console.error(e);
				return timestamp;
			}
		}
		window.addEventListener("load", () => {
			document.body.classList.remove('hidden')
			document.addEventListener("pointerdown", (e) => {
				if (e.target.closest("button, .interact")) {
					createRipple(e, e.target.closest("button, .interact"));
				}
			});
			document.addEventListener('copy', () => {
				notify('copied', 'success')
			})
			getAllSuggestions().then(suggestions => {
				router.routeTo(window.location.hash)
			}).catch(e => {
				console.error(e)
				notify(e, 'error')
			})
			getRef("main_search_field").addEventListener("keydown", function (e) {
				if (e.key === 'Enter') {
					processNavbarSearch()
				} else if (e.key === 'ArrowDown') {
					e.preventDefault();
					getRef('suggestions').firstElementChild.focus()
				}
				if (document.activeElement.classList.contains('suggestion'))
					getRef("main_search_field").value = document.activeElement.textContent.trim()
			});
			getRef('suggestions').addEventListener("keydown", function (e) {
				if (e.key === 'ArrowDown') {
					e.preventDefault();
					if (this.contains(document.activeElement) && document.activeElement.nextElementSibling)
						document.activeElement.nextElementSibling.focus()
				} else if (e.key === 'ArrowUp') {
					e.preventDefault();
					if (this.contains(document.activeElement)) {
						if (document.activeElement.previousElementSibling)
							document.activeElement.previousElementSibling.focus()
						else
							getRef("main_search_field").focusIn()
					}
				}
				if (document.activeElement.classList.contains('suggestion'))
					getRef("main_search_field").value = document.activeElement.textContent.trim()
			});

			this.addEventListener("click", (e) => {
				if (e.target.closest('.suggestion')) {
					let searchBox = document.getElementById('main_search_field');
					searchBox.value = e.target.textContent.trim();
					processNavbarSearch()
				}
			});
		});

		function createRipple(event, target) {
			const circle = document.createElement("span");
			const diameter = Math.max(target.clientWidth, target.clientHeight);
			const radius = diameter / 2;
			const targetDimensions = target.getBoundingClientRect();
			circle.style.width = circle.style.height = `${diameter}px`;
			circle.style.left = `${event.clientX - (targetDimensions.left + radius)}px`;
			circle.style.top = `${event.clientY - (targetDimensions.top + radius)}px`;
			circle.classList.add("ripple");
			const rippleAnimation = circle.animate(
				[
					{
						transform: "scale(3)",
						opacity: 0,
					},
				],
				{
					duration: 1000,
					fill: "forwards",
					easing: "ease-out",
				}
			);
			target.append(circle);
			rippleAnimation.onfinish = () => {
				circle.remove();
			};
		}

		class Router {
			/**
			 * @constructor {object} options - options for the router
			 * @param {object} options.routes - routes for the router
			 * @param {object} options.state - initial state for the router
			 * @param {function} options.routingStart - function to be called before routing
			 * @param {function} options.routingEnd - function to be called after routing
			 */
			constructor(options = {}) {
				const { routes = {}, state = {}, routingStart, routingEnd } = options
				this.routes = routes
				this.state = state
				this.routingStart = routingStart
				this.routingEnd = routingEnd
				this.lastPage = null
				window.addEventListener('hashchange', e => this.routeTo(window.location.hash))
			}
			/**
			 * @param {string} route - route to be added
			 * @param {function} callback - function to be called when route is matched
			 */
			addRoute(route, callback) {
				this.routes[route] = callback
			}
			/**
			 * @param {string} route
			 */
			async routeTo(path) {
				try {
					let page
					let wildcards = []
					let queryString
					let params
					[path, queryString] = path.split('?');
					if (path.includes('#'))
						path = path.split('#')[1];
					if (path.includes('/'))
						[, page, ...wildcards] = path.split('/')
					else
						page = path
					this.state = { page, wildcards, lastPage: this.lastPage }
					if (queryString) {
						params = new URLSearchParams(queryString)
						this.state.params = Object.fromEntries(params)
					}
					if (this.routingStart) {
						this.routingStart(this.state)
					}
					if (this.routes[page]) {
						await this.routes[page](this.state)
						this.lastPage = page
					} else {
						if (this.routes['404']) {
							this.routes['404'](this.state);
						} else {
							console.error(`No route found for '${page}' and no '404' route is defined.`);
						}
					}
					if (this.routingEnd) {
						this.routingEnd(this.state)
					}
				} catch (e) {
					console.error(e)
				}
			}
		}

		const slideInLeft = [
			{
				opacity: 0,
				transform: 'translateX(1rem)'
			},
			{
				opacity: 1,
				transform: 'translateX(0)'
			}
		]
		const slideOutLeft = [
			{
				opacity: 1,
				transform: 'translateX(0)'
			},
			{
				opacity: 0,
				transform: 'translateX(-1rem)'
			},
		]
		const slideInRight = [
			{
				opacity: 0,
				transform: 'translateX(-1rem)'
			},
			{
				opacity: 1,
				transform: 'translateX(0)'
			}
		]
		const slideOutRight = [
			{
				opacity: 1,
				transform: 'translateX(0)'
			},
			{
				opacity: 0,
				transform: 'translateX(1rem)'
			},
		]
		const slideInDown = [
			{
				opacity: 0,
				transform: 'translateY(-1rem)'
			},
			{
				opacity: 1,
				transform: 'translateY(0)'
			},
		]
		const slideOutDown = [
			{
				opacity: 1,
				transform: 'translateY(0)'
			},
			{
				opacity: 0,
				transform: 'translateY(1rem)'
			},
		]
		const slideInUp = [
			{
				opacity: 0,
				transform: 'translateY(1rem)'
			},
			{
				opacity: 1,
				transform: 'translateY(0)'
			},
		]
		const slideOutUp = [
			{
				opacity: 1,
				transform: 'translateY(0)'
			},
			{
				opacity: 0,
				transform: 'translateY(-1rem)'
			},
		]
		function showChildElement(id, index, options = {}) {
			return new Promise((resolve) => {
				const { mobileView = false, entry, exit } = options
				const animOptions = {
					duration: floGlobals.prefersReducedMotion ? 0 : 150,
					easing: 'ease',
					fill: 'forwards'
				}
				const parent = typeof id === 'string' ? document.getElementById(id) : id;
				const visibleElement = [...parent.children].find(elem => !elem.classList.contains(mobileView ? 'hide-on-mobile' : 'hidden'));
				if (visibleElement === parent.children[index]) return;
				visibleElement.getAnimations().forEach(anim => anim.cancel())
				parent.children[index].getAnimations().forEach(anim => anim.cancel())
				if (visibleElement) {
					if (exit) {
						parent.style.overflow = 'hidden'
						visibleElement.animate(exit, animOptions).onfinish = () => {
							visibleElement.classList.add(mobileView ? 'hide-on-mobile' : 'hidden')
							parent.style.overflow = ''
						}
						parent.children[index].classList.remove(mobileView ? 'hide-on-mobile' : 'hidden')
						if (entry) {
							parent.children[index].animate(entry, animOptions).onfinish = () => resolve()
						}
					} else {
						visibleElement.classList.add(mobileView ? 'hide-on-mobile' : 'hidden')
						parent.children[index].classList.remove(mobileView ? 'hide-on-mobile' : 'hidden')
						resolve()
					}
				} else {
					parent.children[index].classList.remove(mobileView ? 'hide-on-mobile' : 'hidden')
					parent.children[index].animate(entry, animOptions).onfinish = () => resolve()
				}
			})
		}
		/**
	 * Creates a signal and returns getter, setter and domNode
	 * @param {string|number} initialState 
	 * @param {function} callback 
	 * @returns {[function, function, function]} [getter, setter, domNode]
	 */
		function $signal(initialState, callback) {
			let state = initialState;
			function changeState(newState) {
				if (newState === state) return;
				state = newState;
				callback && callback(newState);
			}
			return [
				() => state,
				(state) => {
					changeState(state);
				}
			]
		}
	</script>
	<script>
		const render = {
			tokenBalanceCard(token, balance) {
				return html`
				  <li class="token-balance">
					<a href=${`#/token/${token}`} class="label token">${token}</a>
					<h4>${formatAmount(balance, token.toLowerCase() === 'rupee' ? 'inr' : 'usd')}</h4>
				  </li>
				`;
			},
			errorPage(reason) {
				const page = document.createElement('section')
				page.classList.add('page')
				page.id = 'error_page'
				page.innerHTML = `
					<h1>Not found!</h1>
					<p>${reason}</p>
				`
				return page
			},
			addrBalanceCard(address, balance, token) {
				return html`
				  <li class="flex align-center space-between flex-wrap gap-0-5 holder-balance">
					<a href=${`#/address/${address}`} class="address wrap-around">${address}</a>
                    <span>${formatAmount(balance, token.toLowerCase() === 'rupee' ? 'inr' : 'usd')} ${token}</span>
				  </li>
				`;
			},
			participantCard(details) {
				const { participantFloAddress, participationAmount, swapAmount, swapPrice, transactionHash, acceptingToken, sellingToken } = details;
				return html`
					<li class="flex participant">
						<div class="grid gap-0-5 flex-1">
							<div class="flex align-center gap-0-5">
								<svg class="icon" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="#000000"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M6.99 11L3 15l3.99 4v-3H14v-2H6.99v-3zM21 9l-3.99-4v3H10v2h7.01v3L21 9z"/></svg>
								<h5>Token swap</h5>
							</div>	
							<a href=${`#/address/${participantFloAddress}`} class="address wrap-around">${participantFloAddress}</a> 
						</div>
						<div class="grid align-center gap-1 flex-1" style="grid-template-columns: repeat(auto-fill, minmax(8rem, 1fr))">
							<div>
								<h5 class="label">Sent</h5>
								<b>${formatAmount(participationAmount, 'usd')} ${acceptingToken}</b>
							</div>
							<div>
								<h5 class="label">Received</h5>
								<b>${formatAmount(swapAmount, 'usd')} ${sellingToken}</b>
							</div>
							<div>
								<h5 class="label">Exchange rate</h5>
								<b>${formatAmount(swapPrice, 'usd')} ${acceptingToken}</b>
							</div>
						</div>
					</li>
				`;
			},
			depositCard(details) {
				const { currentBalance, depositorAddress, originalBalance, status, time, transactionHash, acceptingToken, sellingToken } = details
				console.log(details)
				return html`
				<li class="flex deposit-card">
					<div class="grid gap-0-5 flex-1">
						<h5>Deposit</h5>
						<a href=${`#/address/${depositorAddress}`} class="address wrap-around">${depositorAddress}</a> 
					</div>
					<div class="grid align-center gap-1 flex-1" style="grid-template-columns: repeat(auto-fill, minmax(8rem, 1fr))">
						<div>
							<h5 class="label">Deposited</h5>
							<b>${formatAmount(originalBalance, 'usd')} ${sellingToken}</b>
						</div>
						<div>
							<h5 class="label">Current balance</h5>
							<b>${formatAmount(currentBalance, 'usd')} ${sellingToken}</b>
						</div>
						<div>
							<h5 class="label">Status</h5>
							<b>${status}</b>
						</div>
					</div>
				</li>
				`
			},
			contractChoiceCard(details) {
				const { participantFloAddress, userChoice, tokenAmount, transactionHash, winningAmount } = details;
				let action;
				if (winningAmount) {
					action = 'Won'
					amount = winningAmount
				} else
					action = 'Invested'
				return html`
					<li class="contract-choice">
						<a href=${`#/address/${participantFloAddress}`} class="address wrap-around">${participantFloAddress}</a>
						<h4>${userChoice}</h4>
						<h4>${formatAmount(tokenAmount, 'usd')} ${action}</h4>
					</li>
				`;
			},
			contractDepositCard(obj) {
				const { hash, blockHeight, token, sender, receiver, amount, type, time, contractAddress, contractName } = obj;
				let title = 'Contract deposit';
				return html`
					<li id=${hash} class="transaction token-transfer">
						<svg class="icon" viewBox="0 0 64 64"> <title>transfer</title> <polyline points="17.04 35.97 14.57 33.5 40.15 7.9 32.75 0.5 55.52 0.5 55.52 23.28 48.12 15.87 23.86 40.14 15.88 48.13 8.48 40.72 8.48 63.5 31.25 63.5 23.85 56.1 49.43 30.5 46.96 28.03"/> </svg>
						<div class="contract-type">
							<h5 class="label">${title}</h5>
							<a href=${`#/token/${token}`} class="">${token}</a>
						</div>
						<div class="contract-info">						
							<time>${getFormattedTime(time)}</time>
							<div class="flex flex-wrap gap-1">	
								<div class="flex flex-direction-column">
									<h5 class="label">Sender</h5>
									<sm-copy value=${sender}>
										<a href=${`#/address/${sender}`} class="address wrap-around">${sender}</a> 
									</sm-copy>
								</div>
								<div class="flex flex-direction-column">
									<h5 class="label">Receiver (Smart contract)</h5>
									<a href=${`#/contract/${contractName}-${receiver}`} class="address wrap-around">${contractName}-${receiver}</a> 
								</div>
							</div>
							<div class="flex flex-direction-column">
								<h5 class="label">Amount</h5>
								<h4>${formatAmount(amount, token.toLowerCase() === 'rupee' ? 'inr' : 'usd')} ${token}</h4>
							</div>
							<div class="flex align-center space-between flex-wrap gap-1">
								<div class="flex flex-direction-column">
									<h5 class="label">Transaction ID</h5>
									<sm-copy value=${hash} clip-text></sm-copy>
								</div>
								<a href=${`#/transaction/${hash}`} class="button button--small button--colored">View details</a>
							</div>
						</div>
					</li>
				`;
			},
			contractTransferCard(obj) {
				const { hash, token, sender, receiver, amount, contractName, userChoice, time } = obj;
				return html`
					<li id=${hash} class="transaction token-transfer">
						<svg class="icon" viewBox="0 0 64 64"> <title>contract</title> <path d="M4.75,49.27A8,8,0,0,0,4.2,61.14a7.82,7.82,0,0,0,4.34,2.24,7.42,7.42,0,0,0,1.34.12H47.41a8.06,8.06,0,0,0,8.05-8V7.87"/> <path d="M8.54,56.13V8.54a8.06,8.06,0,0,1,8.05-8H54.12a7.42,7.42,0,0,1,1.34.12A7.82,7.82,0,0,1,59.8,2.86a8,8,0,0,1-.55,11.87"/> <line x1="17.93" y1="22.62" x2="46.07" y2="22.62"/> <line x1="17.93" y1="32" x2="46.07" y2="32"/> <line x1="17.93" y1="41.38" x2="38.03" y2="41.38"/> </svg>
						<div class="contract-type">
							<h5 class="label">Smart Contract Transfer</h5>
							<a href=${`#/token/${token}`} class="">${token}</a>
						</div>
						<div class="contract-info">
							<time>${getFormattedTime(time)}</time>
							<div class="flex flex-direction-column">
								<h5 class="label">Amount</h5>
								<h4>${formatAmount(amount, token.toLowerCase() === 'rupee' ? 'inr' : 'usd')} ${token}</h4>
							</div>
							<div class="flex flex-direction-column">
									<h5 class="label">Sender</h5>
									<sm-copy value=${sender}>
										<a href=${`#/address/${sender}`} class="address wrap-around">${sender}</a> 
									</sm-copy>
							</div>
							<div class="flex flex-direction-column">
								<h5 class="label">Receiver (Smart contract)</h5>
								<h4><a class="address wrap-around" href=${`#/contract/${contractName}-${receiver}`}>${contractName}-${receiver}</a></h4>
							</div>
							<div class="flex align-center space-between flex-wrap gap-1">
								<div class="flex flex-direction-column">
									<h5 class="label">Transaction ID</h5>
									<sm-copy value=${hash} clip-text></sm-copy>
								</div>
								<a href=${`#/transaction/${hash}`} class="button button--small button--colored">View details</a>
							</div>
						</div>
					</li>`;
			},
			tokenTransferCard(obj) {
				const { hash, blockHeight, token, sender, receiver, amount, type, time } = obj;
				let title = 'Token transfer';
				if (type === 'nfttransfer')
					title = 'NFT transfer';
				return html`
					<li id=${hash} class="transaction token-transfer">
						<svg class="icon" viewBox="0 0 64 64"> <title>transfer</title> <polyline points="17.04 35.97 14.57 33.5 40.15 7.9 32.75 0.5 55.52 0.5 55.52 23.28 48.12 15.87 23.86 40.14 15.88 48.13 8.48 40.72 8.48 63.5 31.25 63.5 23.85 56.1 49.43 30.5 46.96 28.03"/> </svg>
						<div class="contract-type">
							<h5 class="label">${title}</h5>
							<a href=${`#/token/${token}`} class="">${token}</a>
						</div>
						<div class="contract-info">						
							<time>${getFormattedTime(time)}</time>
							<div class="flex flex-wrap gap-1">	
								<div class="flex flex-direction-column">
									<h5 class="label">Sender</h5>
									<sm-copy value=${sender}>
										<a href=${`#/address/${sender}`} class="address wrap-around">${sender}</a> 
									</sm-copy>
								</div>
								<div class="flex flex-direction-column">
									<h5 class="label">Receiver</h5>
									<sm-copy value=${receiver}>
										<a href=${`#/address/${receiver}`} class="address wrap-around">${receiver}</a> 
									</sm-copy>
								</div>
							</div>
							<div class="flex flex-direction-column">
								<h5 class="label">Amount</h5>
								<h4>${formatAmount(amount, token.toLowerCase() === 'rupee' ? 'inr' : 'usd')} ${token}</h4>
							</div>
							<div class="flex align-center space-between flex-wrap gap-1">
								<div class="flex flex-direction-column">
									<h5 class="label">Transaction ID</h5>
									<sm-copy value=${hash} clip-text></sm-copy>
								</div>
								<a href=${`#/transaction/${hash}`} class="button button--small button--colored">View details</a>
							</div>
						</div>
					</li>
				`;
			},
			tokenCreationCard(obj) {
				const { hash, blockHeight, token, incAddress, supply, type, nftHash, time } = obj;
				let title = 'Token creation';
				if (type === 'nftincorp')
					title = 'NFT creation';
				return html`
					<li id=${hash} class="transaction token-creation">
						<svg class="icon" viewBox="0 0 64 64"> <title>token</title> <circle cx="32" cy="32" r="31"/> <circle cx="32" cy="32" r="25.19"/> <line x1="37" y1="21.74" x2="43.14" y2="21.74"/> <path d="M20.86,21.74H32V43.23"/> </svg>
						<div class="contract-type">
							<h5 class="label">${title}</h5>
							<a href=${`#/token/${token}`} class="token uppercase">${token}</a>
						</div>
						<div class="contract-info">
							<time>${getFormattedTime(time)}</time>
							<div class="flex flex-direction-column">
								<h5 class="label">Incorporation address</h5>
								<sm-copy value=${incAddress}>
									<a href=${`#/address/${incAddress}`} class="address wrap-around">${incAddress}</a>
								</sm-copy>
							</div>
							<div class="flex flex-direction-column">
								<h5 class="label">supply</h5>
								<h4>${supply ? formatAmount(supply, token.toLowerCase() === 'rupee' ? 'inr' : 'usd') : 'Infinite'} </h4>
							</div>
							${type === 'nftincorp' ? html`
								<div class="flex flex-direction-column">
									<h5 class="label">NFT hash</h5>
									<sm-copy value="${nftHash}"></sm-copy>
								</div>
							`: ''}
							<div class="flex align-center space-between flex-wrap gap-1">
								<div class="flex flex-direction-column">
									<h5 class="label">Transaction ID</h5>
									<sm-copy value=${hash} clip-text></sm-copy>
								</div>
								<a href=${`#/transaction/${hash}`} class="button button--small button--colored">View details</a>
							</div>
						</div>
					</li>`;
			},
			contractTriggerCard(obj) {
				// TODO: change committee address to actual committee address instead of contract address
				const { hash, blockHeight, contractName, contractAddress, winningChoice, committeeAddress, time } = obj;
				return html`
					<li id=${hash} class="transaction contract-trigger">
						<svg class="icon" viewBox="0 0 64 64"> <circle cx="32" cy="32" r="31"/> <polyline points="32 13.47 32 32 43.4 43.4"/> </svg>
						<div class="contract-type">
							<h5 class="label">smart contract </h5>
							<h4 class="uppercase">trigger</h4>
						</div>
						<div class="contract-info">
							<time>${getFormattedTime(time)}</time>
							<div class="flex flex-direction-column">
								<h5 class="label">contract address</h5>
								<a href=${`#/address/${contractAddress}`} class="address wrap-around">${contractAddress}</a>
							</div>
							<div class="flex flex-direction-column">
								<h5 class="label">Winning Choice</h5>
								<h4>${winningChoice}</h4>
							</div>
							<div class="flex flex-direction-column">
								<h5 class="label">committee address</h5>
								<a href=${`#/address/${committeeAddress}`} class="address wrap-around">${committeeAddress}</a>
							</div>
							<div class="flex align-center space-between flex-wrap gap-1">
								<div class="flex flex-direction-column">
									<h5 class="label">Transaction ID</h5>
									<sm-copy value=${hash} clip-text></sm-copy>
								</div>
								<a href=${`#/transaction/${hash}`} class="button button--small button--colored">View details</a>
							</div>
						</div>
					</li>
				`;
			},
			contractCreationCard(obj) {
				const {
					hash, blockHeight, token, contractName, incAddress, contractType,
					expiration, participationFees, availableChoices, time, acceptingToken, sellingToken, price,
					minAmount, maxAmount } = obj;
				console.log(obj)
				return html`
					<li id=${hash} class="transaction contract-creation">
						<svg class="icon" viewBox="0 0 64 64"> <title>contract creation</title> <path d="M47.07,23.85V11"/> <path d="M3,47A7,7,0,0,0,.48,52.39a6.89,6.89,0,0,0,2.05,4.93,6.78,6.78,0,0,0,3.78,2,6.34,6.34,0,0,0,1.16.1H40.09a7,7,0,0,0,7-7V44"/> <path d="M6.31,53V11.61a7,7,0,0,1,7-7H45.91a6.26,6.26,0,0,1,1.16.1,6.74,6.74,0,0,1,3.78,1.95A7,7,0,0,1,50.37,17"/> <line x1="14.46" y1="23.85" x2="38.92" y2="23.85"/> <line x1="14.46" y1="32" x2="38.92" y2="32"/> <line x1="14.46" y1="40.15" x2="31.93" y2="40.15"/> <path d="M57.79,24.44l-2.88-2.9,3.79-3.79a1,1,0,0,1,1.39,0l3.11,3.11a1,1,0,0,1,0,1.39L40.34,45.1a1,1,0,0,1-.52.28L36,46A1,1,0,0,1,34.9,44.9l.67-3.77a1,1,0,0,1,.27-.52L52.65,23.8"/> </svg>
						<div class="contract-type">
							<h5 class="label">Smart Contract creation</h5>
							<a href=${`#/token/${token}`} class="">${token}</a>
						</div>
						<div class="contract-info">
							<time>${getFormattedTime(time)}</time>
							<div class="flex flex-direction-column">
								<h5 class="label">Contract ID</h5>
								<a href=${`#/contract/${contractName}-${incAddress}`} class="address wrap-around">${contractName}-${incAddress}</a>
							</div>
							<div class="flex flex-direction-column">
								<h5 class="label">contract type</h5>
								<h4>
									${replaceDash(contractType) === 'continuos event' ? 'continuous event' : replaceDash(contractType)}
								</h4>
							</div>
							<div class="flex flex-wrap gap-1-5">
								${token ? html`
									<div class="flex flex-direction-column">
										<h5 class="label">token used</h5>
										<h4>${token}</h4>
									</div>
								`: ''}
								${acceptingToken ? html`
									<div class="flex flex-direction-column">
										<h5 class="label">Participation token</h5>
										<h4>${acceptingToken}</h4>
									</div>
								`: ''}
								${sellingToken ? html`
									<div class="flex flex-direction-column">
										<h5 class="label">Deposit token</h5>
										<h4>${sellingToken}</h4>
									</div>
								`: ''}
								${expiration ? html`
									<div class="flex flex-direction-column">
										<h5 class="label">expiration</h5>
										<h4 class="capitalise">${getFormattedTime(new Date(expiration).getTime())}</h4>
									</div>
								`: ''}
								${participationFees ? html`
									<div class="flex flex-direction-column">
										<h5 class="label">participation amount</h5>
										<h4>${participationFees} ${token}</h4>
									</div>
								`: ''}
								${price ? html`
									<div class="flex flex-direction-column">
										<h5 class="label">price</h5>
										<h4>1 ${sellingToken} = ${formatAmount(price, 'usd')} ${acceptingToken}</h4>
									</div>
								`: ''}
								${minAmount ? html`
									<div class="flex flex-direction-column">
										<h5 class="label">min amount</h5>
										<h4>${minAmount} ${token}</h4>
									</div>	
								`: ''}
								${maxAmount ? html`
									<div class="flex flex-direction-column">
										<h5 class="label">max amount</h5>
										<h4>${maxAmount} ${token}</h4>
									</div>	
								`: ''}
							</div>
							<div class="flex align-center space-between flex-wrap gap-1">
								<div class="flex flex-direction-column">
									<h5 class="label">Transaction ID</h5>
									<sm-copy value=${hash} clip-text></sm-copy>
								</div>
								<a href=${`#/transaction/${hash}`} class="button button--small button--colored">View details</a>
							</div>
						</div>
					</li>`;
			},
			blockCard(blockDetails) {
				const { height, tx, time } = blockDetails;
				const plural = parseInt(tx.length) > 1 ? 's' : '';
				return html`
					<div class="block-card grid align-center">
						<a href=${`#/block/${height}`} class="block-height">${height}</a>
          				<span>${tx.length} Transaction${plural}</span>
						<time>${getFormattedTime(time, 'relative')}</time>
					</div>
				`;
			},
			offChainTransferCard(transferDetails) {
				const { tokenAmount, transactionTrigger, tokenIdentification, contractName, senderAddress, receiverAddress, time, type, hideUnnecessary } = transferDetails;
				return html`
					<li class="transaction">
						<svg class="icon" viewBox="0 0 64 64"> <title>transfer</title> <polyline points="17.04 35.97 14.57 33.5 40.15 7.9 32.75 0.5 55.52 0.5 55.52 23.28 48.12 15.87 23.86 40.14 15.88 48.13 8.48 40.72 8.48 63.5 31.25 63.5 23.85 56.1 49.43 30.5 46.96 28.03"/> </svg>
						<div class="contract-type">
							<div class="flex align-center gap-1">
								<h5 class="label">Token transfer</h5>
								${!hideUnnecessary ? html`<div class="badge">Off-chain</div>` : ''}
							</div>
							<a href=${`#/token/${tokenIdentification}`} class=""><b>${tokenIdentification}</b></a>
						</div>
						<div class="contract-info">
							<time>${getFormattedTime(time)}</time>
							<div class="flex flex-direction-column">
								<h5 class="label">Sender (Smart contract)</h5>
								<a href=${`#/contract/${contractName}-${senderAddress}`} class="address wrap-around">${contractName}-${senderAddress}</a>
							</div>
							<div class="flex flex-direction-column">
								<h5 class="label">Receiver address</h5>
								<sm-copy value=${receiverAddress}>
									<a href=${`#/address/${receiverAddress}`} class="address wrap-around">${receiverAddress}</a>
								</sm-copy>
							</div>
							<div class="flex flex-direction-column">
								<h5 class="label">Amount</h5>
								<h4>${tokenAmount} ${tokenIdentification}</h4>
							</div>
							${!hideUnnecessary ? html`
								<div class="flex align-center space-between flex-wrap gap-1">
									<div class="flex flex-direction-column">
										<h5 class="label">Transfer trigger ID</h5>
										<sm-copy value=${transactionTrigger} clip-text></sm-copy>
									</div>
									<a href=${`#/transaction/${transactionTrigger}`} class="button button--small button--colored">View details</a>
								</div>
							`: ''}
						</div>
					</li>`;
			},
			compoundTransactionCard(details) {
				const { time, hash, sender, receiver, contractName, token, amount, offChainTransactions = [] } = details
				const smartContract = `${contractName}-${receiver}`
				const renderedOffChainTransactions = offChainTransactions.map(tx => {
					const { receiverAddress, tokenAmount, tokenIdentification } = tx
					return html`
						<li class="transfer-step">
							<div class="flex flex-direction-column gap-0-5">
								<div class="flex flex-direction-column gap-0-5">
									<div class="flex align-center gap-0-5">
										<h5 class="label" style="margin-bottom: 0">Sender (Smart contract)</h5>
										<div class="badge">Off-chain</div>
									</div>
									<a href=${`#/contract/${smartContract}`} class="address wrap-around"><b>${smartContract}</b></a>
								</div>
								<p>Sent: <b>${tokenAmount} ${tokenIdentification}</b></p>
							</div>
							<svg class="icon" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="#000000"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M12 4l-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8-8-8z"/></svg>
							<div class="flex flex-direction-column">
								<h5 class="label">Receiver</h5>
								<sm-copy value=${receiverAddress}>
									<a href=${`#/address/${receiverAddress}`} class="address wrap-around">${receiverAddress}</a>
								</sm-copy>
							</div>
						</li>
					`
				})
				return html`
					<li class="transaction">
						<svg class="icon" viewBox="0 0 64 64"> <title>transfer</title> <polyline points="17.04 35.97 14.57 33.5 40.15 7.9 32.75 0.5 55.52 0.5 55.52 23.28 48.12 15.87 23.86 40.14 15.88 48.13 8.48 40.72 8.48 63.5 31.25 63.5 23.85 56.1 49.43 30.5 46.96 28.03"/> </svg>
						<div class="contract-type flex flex-direction-column gap-0-5">
							<h4>Smart contract transfer</h4>
							<time>${getFormattedTime(time)}</time>
						</div>
						<div class="contract-info">
							<ul class="transfer-steps">
								<li class="transfer-step">
									<div class="flex flex-direction-column gap-0-5">
										<div class="flex flex-direction-column">
											<h5 class="label">Sender</h5>
											<sm-copy value=${sender}>
												<a href=${`#/address/${sender}`} class="address wrap-around">${sender}</a>
											</sm-copy>
											<p>Sent: <b>${amount} ${token}</b></p>
										</div>
									</div>
									<svg class="icon" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="#000000"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M12 4l-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8-8-8z"/></svg>
									<div class="flex flex-direction-column">
										<h5 class="label">Receiver (Smart contract)</h5>
										<a href=${`#/contract/${smartContract}`} class="address wrap-around">${smartContract}</a>
									</div>
								</li>
								${renderedOffChainTransactions}
							</ul>	
							<div class="flex align-center space-between flex-wrap gap-1">
								<div class="flex flex-direction-column">
									<h5 class="label">Transaction ID</h5>
									<sm-copy value=${hash} clip-text></sm-copy>
								</div>
								<a href=${`#/transaction/${hash}`} class="button button--small button--colored">View details</a>
							</div>
						</div>
					</li>
				`
			}
		};
		const router = new Router({
			routingStart(state) {
				loading()
				document.body.style.overflow = 'hidden'
				if (state.page !== 'home')
					getRef("page_header").classList.remove("hidden");
			},
			routingEnd() {
				loading(false)
				document.body.style.overflow = 'auto'
				window.scrollTo(0, 0);
			}
		})
		async function renderHome(state) {
			getRef("page_header").classList.add("hidden");
			let [data, latestTxs, latestBlocks] = await Promise.all([getBannerData(), getLatestTxs(), getAllBlocks(6)])
			const { height, time } = latestBlocks[0]
			const { topToken, totalTransactions, walletAddresses } = data;
			renderElem(getRef("page_container"), html`
				<div id="homepage" class="page">
					<section id="first_section">
						<div id="highlights">
							<div class="highlight-item">
								<h4 class="label">top token</h4>
								<h2 class="token"><a href=${`#/token/${topToken}`} class="">${topToken}</a> </h2>
							</div>
							<div class="highlight-item">
								<h4 class="label">Total transactions</h4>
								<h2>${totalTransactions}</h2>
							</div>
							<div class="highlight-item">
								<h4 class="label">Wallet addresses</h4>
								<h2>${walletAddresses}</h2>
							</div>
							<div class="highlight-item">
								<h4 class="label">Last token transaction block (${getFormattedTime(time, 'relative')})</h4>
								<h2><a class="block-height" href=${`#/block/${height}`}>${height}</a></h2>
							</div>
						</div>
					</section>
					<section id="latest_transaction_section" class="margin-bottom-2">
						<header class="flex align-center space-between">
							<h3>Recent token transactions</h3>
							<a id='all_trans_btn' href=${`#/transactions`} class="button button--small button--colored">View all</a>
						</header>
						<ul id="top_transaction_container" class="transaction-container">
							${renderTransactions(latestTxs)}
						</ul>
					</section>
					<section id="latest_blocks_section">
						<header class="flex align-center space-between">
							<h3>Recent token transaction blocks</h3>
							<a id='all_blocks_btn' href=${`#/blocks`} class="button button--small button--colored">View all</a>
						</header>
						<div id="top_blocks_container">
							${latestBlocks.map(block => render.blockCard(block))}
						</div>
					</section>
				</div>
			`);
		}
		router.addRoute('', async (state) => {
			history.replaceState({}, '', '#/home')
			await renderHome(state)
		})
		router.addRoute('home', renderHome)
		floGlobals.appliedFilters = {
			tokens: new Set(),
			types: new Set()
		}
		function filterSmartContracts() {
			if (getRef('token_filter_list'))
				floGlobals.appliedFilters.tokens = new Set([...getRef('token_filter_list').querySelectorAll('input[type="checkbox"]:checked')]
					.map(elem => elem.value))
			if (getRef('type_filter_list'))
				floGlobals.appliedFilters.types = new Set([...getRef('type_filter_list').querySelectorAll('input[type="checkbox"]:checked')]
					.map(elem => elem.value))

			let filteredContracts = floGlobals.smartContractList
			const { tokens, types } = floGlobals.appliedFilters
			if (tokens.size || types.size) {
				filteredContracts = filteredContracts.filter(sc => {
					const { acceptingToken, sellingToken, contractSubType, tokenIdentification } = sc
					if (tokens.size && !tokens.has(acceptingToken) && !tokens.has(sellingToken) && !tokens.has(tokenIdentification))
						return false
					if (types.size && !types.has(contractSubType))
						return false
					return true
				})
			}
			const totalFilters = tokens.size + types.size
			getRef('apply_filter_button').lastChild.textContent = totalFilters ? `Filter (${totalFilters})` : 'Filter';
			if (getRef('clear_filter_button'))
				getRef('clear_filter_button').classList[totalFilters ? 'remove' : 'add']('hidden')
			return filteredContracts
		}
		function renderSmartContracts() {
			const smartContracts = filterSmartContracts().map(contract => {
				const { tokenIdentification, acceptingToken, blockNumber, contractAddress, contractName, contractSubType,
					contractType, incorporationDate, oracle_address, price, sellingToken, status, transactionHash } = contract
				let type = ''
				let actions
				switch (contractSubType) {
					case 'tokenswap':
						type = 'Token Swap'
						actions = html`
							<div class="flex align-center gap-0-5">
								<button class="button button--small button--colored" onclick=${() => openPopup('token_swap_popup', contract)}>
									Sell ${acceptingToken}
								</button>
								<button class="button button--small button--colored" onclick=${() => openPopup('token_swap_popup', contract, true)}>
									Sell ${sellingToken}
								</button>
							</div>
						`
						break;
					case 'time-trigger':
						type = 'Timed Event'
						actions = html`
							<div class="flex align-center gap-0-5">
								<button class="button button--small button--colored" onclick=${() => openPopup('time_trigger_popup', contract)}>
									Participate
								</button>
							</div>
						`
						break;
					case 'external-trigger':
						type = 'External Trigger'
						actions = html`
							<div class="flex align-center gap-0-5">
								<button class="button button--small button--colored" onclick=${() => openPopup('external_trigger_popup', contract)}>
									Participate
								</button>
							</div>
						`
						break;
				}
				return html`
					<li class="sc-card">
						<div class="flex align-center space-between">
							<p class="sc-card__type">${type}</p>
							<a href=${`#/contract/${contractName}-${contractAddress}`} class="sc-card__info-link">
								View details
								<svg class="icon" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="#000000"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M10.02 6L8.61 7.41 13.19 12l-4.58 4.59L10.02 18l6-6-6-6z"/></svg>	
							</a>
						</div>
						<h4>${contractName}</h4>
						<ul class="flex align-center flex-wrap gap-0-5 involved-tokens">
							${tokenIdentification ? html`
								<li>
									<a href=${`#/token/${tokenIdentification}`} class="token">${tokenIdentification}</a>
								</li>
							`: ''}
							${acceptingToken ? html`
								<li>
									<a href=${`#/token/${acceptingToken}`} class="token">${acceptingToken}</a>
								</li>
							`: ''}
							${sellingToken ? html`
								<li>
									<a href=${`#/token/${sellingToken}`} class="token">${sellingToken}</a>
								</li>
							`: ''}
						</ul>
						${actions}
					</li>	
				`
			})
			renderElem(getRef('smart_contract_wrapper'), html`
				${smartContracts.length ? html`
					<ul id="smart_contract_list">
						${smartContracts}
					</ul>
				`: html`
					<div class="flex flex-direction-column align-center">
						<h3>No smart contracts found</h3>
						<p>Try changing the filters</p>
					</div>
				`}
			`)
			closePopup()
		}
		function clearFilters() {
			floGlobals.appliedFilters = {
				tokens: new Set(),
				types: new Set()
			}
			if (getRef('token_filter_list'))
				getRef('token_filter_list').querySelectorAll('input[type="checkbox"]:checked').forEach(elem => elem.checked = false)
			if (getRef('type_filter_list'))
				getRef('type_filter_list').querySelectorAll('input[type="checkbox"]:checked').forEach(elem => elem.checked = false)
			renderSmartContracts()
			closePopup()
		}
		router.addRoute('smart-contracts', async state => {
			renderElem(getRef("page_container"), html`
				<div id="smart_contract_page" class="page">
					<header class='flex space-between flex-wrap gap-1'>
						<h2>Smart contracts</h2>
						<div class="flex align-center gap-0-5">
							<button id="clear_filter_button" class="button button--small button--colored gap-0-3 hidden" onclick=${clearFilters}>
								<svg class="icon" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="#000000"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
								Clear
							</button>
							<button id="apply_filter_button" class="button button--small button--colored gap-0-3" onclick=${() => openPopup('filter_s_c_popup')}>
								<svg class="icon" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="#000000"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z"/></svg>
								Filter
							</button>
						</div>	
					</header>
					<div id="smart_contract_wrapper"></div>
				</div>
			`)
			renderSmartContracts()
			getRef("page_title").textContent = '';
		})
		router.addRoute('address', async state => {
			try {
				const [floAddress] = state.wildcards
				if (!floAddress) return;
				let [ownedTokens = {}, floBalance, addressTxs] = await Promise.all([getAddressInfo(floAddress), getAddressBalance(floAddress), getAddressTxs(floAddress)])
				const ownedTokensCards = []
				for (const token in ownedTokens) {
					render.tokenBalanceCard(token, ownedTokens[token].balance || 0)
				}
				renderElem(getRef("page_container"), html`
					<div id="address_page" class="page">
						<div class="balance-card">
							<h2 class="wrap-around margin-bottom-2">${floAddress}</h2>
							<h5 class="label">FLO Balance</h5>
							<h3 class="margin-bottom-2">${floBalance} FLO</h3>
							${ownedTokensCards.length ? html`
								<div class="grid gap-0-5">
									<h5>Tokens</h5>
									<ul id="token_balance_list">
										${ownedTokensCards}
									</ul>
								</div>
							`: ''}
						</div>
						<h4>Transactions</h4>
						<ul id="address_transaction_container" class="transaction-container">
							${renderTransactions(addressTxs)}
						</ul>
					</div>
				`);
				getRef("page_title").textContent = 'Address';

			} catch (e) {
				console.error(e)
				renderElem(getRef("page_container"), html`${render.errorPage(e)}`);
			}
		})
		router.addRoute('token', async state => {
			const token = state.wildcards[0].toLowerCase()
			if (!token) return;
			try {
				let [tokenInfo, tokenBalances, tokenTransactions] = await Promise.all([getTokenInfo(token), getTokenBalances(token), getTokenTransactions(token)])
				let { supply, incAddress } = tokenInfo
				const tokenHolders = []
				for (const address in tokenBalances) {
					tokenHolders.push(render.addrBalanceCard(address, tokenBalances[address], tokenInfo.token))
				}
				renderElem(getRef("page_container"), html`
					<div id="token_page" class="page">
						<div class="card">
						<h2 class="uppercase">${token}</h2>
						<h5 class="label">Supply</h5>
						<h4>${supply ? formatAmount(supply, token.toLowerCase() === 'rupee' ? 'inr' : 'usd') : 'Infinite'}</h4>
						<h5 class="label">Incorporation address</h5>
						<sm-copy value=${incAddress}>
							<h4 class="wrap-around">
								<a href=${`#/address/${incAddress}`} class="address wrap-around">${incAddress}</a> 	
							</h4>
						</sm-copy>
						</div>
						<sm-chips data-target="token_views" onchange="changeView(event)">
							<sm-chip value="0" selected>Transactions</sm-chip>
							<sm-chip value="1">Token holders</sm-chip>
						</sm-chips>
						<div id="token_views" class="view-wrapper">
							<ul id="token_transaction_container" class="transaction-container">
								${renderTransactions(tokenTransactions)}
							</ul>
							<ul id="token_balance_container" class="hidden">
								${tokenHolders?.length ? tokenHolders : html`<div>No token holders found</div>`}
							</ul>
						</div>
					</div>
				`);
				getRef("page_title").textContent = "Token";
			} catch (e) {
				console.trace(e)
				renderElem(getRef("page_container"), html`${render.errorPage(e)}`);
			}
		})
		router.addRoute('contract', async state => {
			try {
				const [contractId] = state.wildcards
				if (!contractId) return;
				const contractIdObj = splitContractNameAddress(contractId)
				const {
					status, contract, contractType, contractSubtype, contractAddress, expiration, token,
					participationFees, userChoices, payeeAddress, minAmount, maxAmount, acceptingToken,
					sellingToken, numberOfDeposits, numberOfParticipants, totalHonorAmount, totalParticipationAmount,
					priceType, oracle_address, price, currentDepositBalance
				} = await getContractInfo(contractIdObj)
				const detailsToFetch = [getContractTransactions(contractIdObj), getContractParticipants(contractIdObj)]
				if (contractType === 'continuos-event' && contractSubtype === 'tokenswap')
					detailsToFetch.push(getContractDeposits(contractIdObj))
				let [contractTransactions, contractParticipants, contractDeposits] = await Promise.all(detailsToFetch)
				let participants = [];
				let winners = []
				let deposits = contractDeposits.map(deposit => render.depositCard({ ...deposit, acceptingToken, sellingToken }))
				for (const participant in contractParticipants) {
					participants.push(render.participantCard(contractParticipants[participant]))
					if (contractParticipants[participant].winningAmount)
						winners.push(render.contractChoiceCard(contractParticipants[participant]))
				}
				renderElem(getRef("page_container"), html`
					<div id="contract_page" class="page">
						${status ? html` <div class=${`status ${status}`}>${status}</div> ` : ''}
                    	<h2 class="uppercase">${replaceDash(contract)}</h2>
						<div id="contract_info" class="card">
							<div class="flex info-row">
								<h5 class="label">Contract Type</h5>
								<h4>${replaceDash(contractType) === 'continuos event' ? 'continuous event' : replaceDash(contractType)}</h4>
							</div>
							${contractSubtype ? html`
								<div class="flex info-row">
									<h5 class="label">Contract Subtype</h5>
									<h4>${replaceDash(contractSubtype)}</h4>
								</div>
							`: ''}
							<div class="flex info-row">
								<h5 class="label">Contract Address</h5>
								<a href=${`#/address/${contractAddress}`} class="address wrap-around">${contractAddress}</a>
							</div>
							${expiration ? html`
								<div class="flex info-row">
									<h5 class="label">Expiration</h5>
									<h4>${getFormattedTime(new Date(expiration).getTime())}</h4>
								</div>
							`: ''}
							${payeeAddress ? html`
								<div class="flex info-row">
									<h5 class="label">Payee Addresses</h5>
									<div class="grid gap-0-5">
										${Object.keys(payeeAddress).map(address => html`
											<a href=${`#/address/${address}`} class="address wrap-around">${address}</a>
										`)}
									</div>
								</div>
							`: ''}
							${minAmount ? html`
								<div class="flex info-row">
									<h5 class="label">Min. Subscription Amount</h5>
									<h4>${formatAmount(minAmount, 'usd')} ${token}</h4>
								</div>
							`: ''}
							${maxAmount ? html`
								<div class="flex info-row">
									<h5 class="label">Max. Subscription Amount</h5>
									<h4>${formatAmount(maxAmount, 'usd')} ${token}</h4>
								</div>
							`: ''}
							${participationFees ? html`
								<div class="flex info-row">
									<h5 class="label">Participation Fees</h5>
									<h4>${formatAmount(participationFees, 'usd')} ${token}</h4>
								</div>
							`: ''}
							${contractType === 'one-time-event' ? html`
								<div class="flex info-row">
									<h5 class="label">Token Used</h5>
									<h4>${token}</h4>
								</div>
							`: ''}
							${contractType === 'continuos-event' && contractSubtype === 'tokenswap' ? html`
								<div class="flex info-row">
									<h5 class="label">deposit token</h5>
									<h4>${sellingToken}</h4>
								</div>
								<div class="flex info-row">
									<h5 class="label">participation token</h5>
									<h4>${acceptingToken}</h4>	
								</div>
								<div class="flex info-row">
									<h5 class="label">Exchange rate (${priceType === 'dynamic' ? 'Dynamic' : 'Fixed'})</h5>
									<h4>1 ${sellingToken} = ${price} ${acceptingToken}</h4>
								</div>
							`: ''}
							${numberOfDeposits ? html`
								<div class="flex info-row">
									<h5 class="label">Number of deposits</h5>
									<h4>${numberOfDeposits}</h4>
								</div>
							`: ''}
							${numberOfParticipants ? html`
								<div class="flex info-row">
									<h5 class="label">Number of participants</h5>
									<h4>${numberOfParticipants}</h4>
								</div>
							`: ''}
							${oracle_address ? html`
								<div class="flex info-row">
									<h5 class="label">Oracle address</h5>
									<a href=${`#/address/${oracle_address}`} class="address wrap-around">${oracle_address}</a>
								</div>
							`: ''}
							${totalParticipationAmount ? html`
								<div class="flex info-row">
									<h5 class="label">Total participation amount</h5>
									<h4>${formatAmount(totalParticipationAmount, 'usd')} ${acceptingToken}</h4>
								</div>
							`: ''}
							${totalHonorAmount ? html`
								<div class="flex info-row">
									<h5 class="label">Total output amount</h5>
									<h4>${formatAmount(totalHonorAmount, 'usd')} ${sellingToken}</h4>
								</div>
							`: ''}
							${currentDepositBalance ? html`
								<div class="flex info-row">
									<h5 class="label">Total deposit balance </h5>
									<h4>${formatAmount(currentDepositBalance, 'usd')} ${sellingToken}</h4>
								</div>
							`: ''}
						</div>
						${userChoices ? html`
							<h3>Available Choices</h3>
							<ul type="circle" class="card">
								${Object.keys(userChoices).map(choice => html`
									<li>${userChoices[choice]}</li>
								`)}
							</ul>
						`: ''}
						<sm-chips class="margin-top-1" data-target="contract_views" onchange="changeView(event)">
							<sm-chip value="0" selected>Transactions</sm-chip>
							<sm-chip value="1">Participants</sm-chip>
							${winners?.length ? html`<sm-chip value="2">Winners</sm-chip>` : ''}
							${deposits?.length ? html`<sm-chip value="2">Deposits</sm-chip>` : ''}
						</sm-chips>
						<div id="contract_views" class="view-wrapper">
							<ul id="contract_transaction_container" class="transaction-container">
								${renderTransactions(contractTransactions)}	
							</ul>
							<ul id="participant_container" class="card hidden">
								${participants?.length ? participants : html`<div>No participants found</div>`}	
							</ul>
							${winners?.length ? html`<ul id="winners_container" class="card hidden">${winners}</ul>` : ''}
							${deposits?.length ? html`<ul id="deposits_container" class="card hidden">${deposits}</ul>` : ''}
						</div>
					</div>
				`);
				getRef("page_title").textContent = "Contract";
			} catch (e) {
				console.trace(e)
				renderElem(getRef("page_container"), html`${render.errorPage(e)}`);
			}
		})

		router.addRoute('block', async state => {
			const [blockId] = state.wildcards
			if (!blockId) return;
			try {
				const [blockInfo, blockTxs] = await Promise.all([getBlockInfo(blockId), getBlockTransactions(blockId)])
				const { blockHeight, size, transactions, reward, hash, difficulty, nonce } = blockInfo;
				renderElem(getRef("page_container"), html`
					<div id="block_page" class="page">
						<h5 class="label">Block Height</h5>
						<h2 class="block-height">${blockHeight}</h2>
						<div class="card">
							<h5 class="label">Relevant Transactions</h5>
							<h4>${transactions.length}</h4>
							<h5 class="label">Confirmations</h5>
							<h4>${size}</h4>
							<h5 class="label">Reward</h5>
							<h4>${reward}</h4>
							<h5 class="label">Block Hash</h5>
							<sm-copy value=${hash} clip-text></sm-copy>
							<h5 class="label">Difficulty</h5>
							<h4>${difficulty}</h4>
							<h5 class="label">Nonce</h5>
							<h4>${nonce}</h4>
						</div>
						<h3 class="heading">Transactions</h3>
						<ul id="block_transaction_container" class="grid gap-1 top-bottom-padding">
							${renderTransactions(blockTxs)}	
						</ul>
					</div>
				`);
				getRef("page_title").textContent = 'Block'
			} catch (e) {
				console.error(e)
				renderElem(getRef("page_container"), html`${render.errorPage(e)}`);
			}
		})
		router.addRoute('blocks', async state => {
			let allBlocks = await getAllBlocks(100);
			getRef("page_title").textContent = "All blocks with token transactions";
			renderElem(getRef("page_container"), html`
				<div id="all_blocks_page" class="page">
					${allBlocks.map(block => render.blockCard(block))}
				</div>
			`)
		})
		router.addRoute('transactions', async state => {
			let allTxs = await getAllTxs();
			getRef("page_title").textContent = "All token transactions";
			renderElem(getRef("page_container"), html`
				<div id="all_transactions_page" class="page"> 
					<ul id="all_transaction_list" class="transaction-container">
						${renderTransactions(allTxs)}
					</ul>	
				</div>
			`)
		})
		router.addRoute('transaction', async state => {
			try {
				const [txId] = state.wildcards
				if (!txId) return
				const [status, txInfo] = await getTxInfo(txId);
				if (!status)
					return renderElem(getRef("page_container"), html`${render.errorPage(txInfo)}`);
				const { type, name, blockHeight, amount, sender, receiver, floData, hash, confirmations, nftHash, subTransactions, time } = txInfo;
				switch (type.trim()) {
					case 'smartContractPays':
					case 'smartContractPays':
						name = ''
						break
					case 'nftIncorporation':
						type = 'NFT Incorporation'
						break
					case 'nft transfer':
						type = 'NFT Transfer'
						break
				}
				const renderedSubTransactions = subTransactions?.map(tx => render.offChainTransferCard({ ...tx, hideUnnecessary: true }));
				renderElem(getRef("page_container"), html`
					<div id="transaction_page" class="page">
						<div class='head'>
							<h5 class="label">${type}</h5>
							<h2 class="token uppercase">
								<a href=${`#/token/${name}`} style="text-decoration:none;">${name}</a>
							</h2>
							<h5 class="label">Transaction ID</h5>
							<sm-copy value=${hash} clip-text></sm-copy>
						</div>
						<div class="flex flex-wrap gap-1">
							<div class="card grid gap-1-5">
								<time class="label">${getFormattedTime(time)}</time>
								<div class="flex flex-direction-column">
									<h5 class="label">Sender</h5>
									<sm-copy value=${sender}>
										<a href=${`#/address/${sender}`} class="address wrap-around">${sender}</a>
									</sm-copy>
								</div>
								${receiver ? html`
									<div class="flex flex-direction-column">
										<h5 class="label">Receiver</h5>
										<sm-copy value=${receiver}>
											<a href=${`#/address/${receiver}`} class="address wrap-around">${receiver}</a>
										</sm-copy>
									</div>
								`: ''}
								${amount ? html`
									<div class="flex flex-direction-column">
										<h5 class="label">Amount</h5>
										<h4>${formatAmount(amount, 'usd')}</h4>
									</div>
								`: ''}
							</div>
							<div class="card flex-1">
								<h5 class="label">FLO Data</h5>
								<p class="wrap-around">${floData}</p>
								<h5 class="label">Block</h5>
								<a href=${`#/block/${blockHeight}`} class="block-height">${blockHeight}</a>
								<h5 class="label">Block Confirmations</h5>
								<h4>${confirmations}</h4>
								${nftHash ? html`
									<h5 class="label">NFT hash</h5>
									<sm-copy value=${nftHash} clip-text></sm-copy>
								`: ''}
							</div>
						</div>
						${subTransactions?.length ? html`
							<div class="grid gap-1">
								<div class="grid gap-0-3">
									<h4>Sub Transactions</h4>
									<p>These are Off-chain transactions that are triggered by above transaction</p>
								</div>
								<ul class="grid gap-1">${renderedSubTransactions}</ul>
							</div>	
						`: ''}
					</div>
				`);
				getRef("page_title").textContent = "Transaction";
			} catch (e) {
				console.error(e)
				renderElem(getRef("page_container"), html`${render.errorPage(e)}`);
			}
		})
		router.addRoute('404', state => {
			renderElem(getRef("page_container"), html`${render.errorPage('404 Not Found')}`);
		})
		function loading(show = true) {
			if (show) {
				getRef('loading').classList.remove('hidden')
			} else {
				getRef('loading').classList.add('hidden')
			}
		}

		function replaceDash(string) {
			return string.replace(/-/g, " ");
		}

		function replaceSpace(str) {
			return str.replace(/ /g, "-");
		}

		function renderTransactions(transactions = []) {
			let parsedTxs = parseTransactions(transactions);
			let groupedTxs = new Map();

			parsedTxs.forEach((tx) => {
				const { hash, transactionTrigger } = tx;
				const key = hash || transactionTrigger;

				if (!groupedTxs.has(key)) {
					groupedTxs.set(key, {
						sourceTransaction: null,
						offChainTransactions: [],
						type: transactionTrigger ? 'compoundTransaction' : undefined,
					});
				}

				if (hash) {
					groupedTxs.get(key).sourceTransaction = tx;
				} else {
					const { tokenIdentification, senderAddress, receiverAddress, onChain, tokenAmount } = tx;
					groupedTxs.get(key).offChainTransactions.push({
						tokenIdentification,
						receiverAddress,
						tokenAmount,
					});
				}
			});

			// Convert the Map to an array of values for sorting
			const sortedTxs = [...groupedTxs.values()].sort((a, b) => b.sourceTransaction.time - a.sourceTransaction.time);

			// Replace parsedTxs with sortedTxs
			parsedTxs = sortedTxs.map((tx) => {
				if (tx.type === 'compoundTransaction') {
					return {
						...tx.sourceTransaction,
						offChainTransactions: tx.offChainTransactions,
						type: tx.type,
					};
				}
				return tx.sourceTransaction;
			});
			console.log(parsedTxs)
			const renderedTransactions = parsedTxs.map(tx => {
				switch (tx.type) {
					case 'tokentransfer':
					case 'nfttransfer':
						return render.tokenTransferCard(tx)
					case 'contractdeposit':
						return render.contractDepositCard(tx)
					case 'contracttransfer':
						return render.contractTransferCard(tx);
					case 'tokenincorp':
					case 'nftincorp':
						return render.tokenCreationCard(tx);
					case 'contractincorp':
						return render.contractCreationCard(tx);
					case 'contracttrigger':
						return render.contractTriggerCard(tx);
					case 'offChainTransfer':
						return render.offChainTransferCard(tx);
					case 'compoundTransaction':
						return render.compoundTransactionCard(tx)
				}
			})
			return html`${renderedTransactions.length ? renderedTransactions : html`<div class="no-results">No transactions found</div>`}`
		}

		getRef('suggestions').addEventListener('keyup', e => {
			if (e.target.closest('.suggestion') && e.key === 'Enter') {
				processNavbarSearch()
			} else if (e.target.closest('.suggestion') && e.key === 'Tab') {
				getRef('main_search_field').value = e.target.textContent;
			}
		})
		getRef('main_search_field').addEventListener('input', debounce(e => {
			let results = flexSearchIndex.search(e.target.value, 10)
			const renderedSuggestions = results.map(suggestionIndex => {
				return html`
					<li class="suggestion wrap-around" tabindex="0">
						${allSuggestions[suggestionIndex]}
					</li>
				`
			})
			renderElem(getRef('suggestions'), html`${renderedSuggestions}`)
		}, 100))
		async function getBannerData() {
			const { systemTransactionCount, systemAddressCount } = await fetchJson(`${floGlobals.tokenApiUrl}/api/v2/info`)
			return {
				topToken: "RUPEE",
				totalTransactions: systemTransactionCount,
				walletAddresses: systemAddressCount,
			}
		}
		let currentViewIndex = 0;
		function changeView(e) {
			const targetWrapper = e.target.dataset.target;
			const viewIndex = parseInt(e.target.value);
			showChildElement(targetWrapper, viewIndex, { entry: viewIndex > currentViewIndex ? slideInLeft : slideInRight, exit: viewIndex > currentViewIndex ? slideOutLeft : slideOutRight });
			currentViewIndex = viewIndex;
		}

		function getLatestTxs() {
			return new Promise((resolve, reject) => {
				fetchJson(`${floGlobals.tokenApiUrl}/api/v2/latestTransactionDetails?limit=4`)
					.then(function (latestTxs) {
						resolve(latestTxs.latestTransactions)
					}).catch((err) => {
						reject(err)
					});
			})
		}

		function getTokenInfo(thisToken) {
			return new Promise((resolve, reject) => {
				fetchJson(
					`${floGlobals.tokenApiUrl}/api/v2/tokenInfo/${thisToken.toLowerCase()}`
				).then(function (tokenInfo) {
					if (tokenInfo.result === "error")
						reject(tokenInfo.description);
					let associatedSC = {};
					tokenInfo.associatedSmartContracts.forEach((sc) => {
						associatedSC[`${sc.contractName}-${sc.contractAddress}`] = sc;
					});
					resolve({
						token: tokenInfo["token"],
						supply: tokenInfo["tokenSupply"],
						incAddress: tokenInfo["incorporationAddress"],
						associatedContracts: associatedSC,
						blockchainReference: tokenInfo["blockchainReference"],
					});
				}).catch((err) => {
					reject(err);
				});
			})
		}

		async function getTokenBalances(tokenName) {
			const tokenDetails = await fetchJson(`${floGlobals.tokenApiUrl}/api/v2/tokenBalances/` + tokenName)
			return tokenDetails.balances
		}

		async function getTokenTransactions(tokenName) {
			const transactions = await fetchJson(`${floGlobals.tokenApiUrl}/api/v2/tokenTransactions/` + tokenName)
			return transactions.transactions
		}

		async function getBlockInfo(thisBlock) {
			const info = await fetchJson(`${floGlobals.tokenApiUrl}/api/v2/blockDetails/${thisBlock}`);
			const { height, size, reward, hash, difficulty, nonce, tx } = info.blockDetails
			return {
				blockHeight: height,
				size: size,
				transactions: tx,
				reward: reward,
				hash: hash,
				difficulty: difficulty,
				nonce: nonce,
			}
		}

		async function getBlockTransactions(thisBlock) {
			const blockTransactions = await fetchJson(`${floGlobals.tokenApiUrl}/api/v2/blockTransactions/${thisBlock}`)
			return blockTransactions.transactions
		}

		async function getContractInfo(contract) {
			const info = await fetchJson(`${floGlobals.tokenApiUrl}/api/v2/smartContractInfo?contractName=${contract.name}&contractAddress=${contract.address}`);
			const {
				contractInfo: {
					contractType,
					numberOfDeposits,
					numberOfParticipants,
					priceType,
					oracle_address,
					contractSubtype,
					status,
					expiryTime,
					payeeAddress,
					userChoices,
					tokenIdentification,
					acceptingToken,
					sellingToken,
					contractAmount,
					minimumsubscriptionamount,
					maximumsubscriptionamount,
					totalHonorAmount,
					totalParticipationAmount,
					price,
					currentDepositBalance
				}, contractAddress,
				contractName
			} = info
			return {
				contract: contractName,
				contractAddress,
				contractType,
				contractSubtype,
				status,
				expiration: expiryTime,
				payeeAddress,
				userChoices,
				token: tokenIdentification,
				acceptingToken,
				sellingToken,
				participationFees: contractAmount,
				minAmount: minimumsubscriptionamount,
				maxAmount: maximumsubscriptionamount,
				numberOfDeposits,
				numberOfParticipants,
				priceType,
				oracle_address,
				totalHonorAmount,
				totalParticipationAmount,
				price,
				currentDepositBalance
			}
		}

		async function getContractParticipants(contract) {
			const participants = await fetchJson(`${floGlobals.tokenApiUrl}/api/v2/smartContractParticipants?contractName=${contract.name}&contractAddress=${contract.address}`)
			return participants.participantInfo
		}

		async function getContractTransactions(contract) {
			const transactions = await fetchJson(`${floGlobals.tokenApiUrl}/api/v2/smartContractTransactions?contractName=${contract.name}&contractAddress=${contract.address}`)
			return transactions.contractTransactions
		}

		async function getContractDeposits(contract) {
			console.log(`${floGlobals.tokenApiUrl}/api/v2/smartContractDeposits?contractName=${contract.name}&contractAddress=${contract.address}`)
			const deposits = await fetchJson(`${floGlobals.tokenApiUrl}/api/v2/smartContractDeposits?contractName=${contract.name}&contractAddress=${contract.address}`)
			return deposits.depositInfo
		}
		function getReceiver(vin, vout) {
			return vout.find(output => output.scriptPubKey.addresses.find(address => address !== vin[0].addr))?.scriptPubKey.addresses[0] || vin[0].addr
		}

		function parseTransactions(txList) {
			if (!Array.isArray(txList))
				txList = [txList]
			let latestTxArray = [];
			txList.forEach(tx => {
				const {
					txid,
					blockHeight,
					vin,
					vout,
					time,
					receiverAddress,
					senderAddress,
					contractAddress,
					contractType,
					contractConditions: {
						expiryTime, accepting_token, selling_token, subtype, price,
						participationAmount, minimumsubscriptionamount, maximumsubscriptionamount
					} = {},
					contractAmount,
					type,
					tokenAmount,
					transferType,
					triggerCondition,
					userChoice,
					nftHash,
					depositAmount,
					contractName,
					tokenIdentification,
					transactionTrigger,
					onChain
				} = tx;
				let obj = {
					hash: txid,
					blockHeight,
					time
				};
				if (onChain) {
					if (type != "smartContractPays") {
						// determine token
						obj["token"] = tokenIdentification;
						switch (type) {
							case 'transfer':
								if (transferType == "token" || transferType == 'nft') {
									obj = Object.assign({}, obj, {
										sender: senderAddress,
										receiver: receiverAddress,
										amount: tokenAmount,
										type: transferType == "token" ? "tokentransfer" : "nfttransfer",
									});
									latestTxArray.push(obj);
									break;
								} else if (transferType == 'smartContract') {
									// smart contract transfer
									obj = Object.assign({}, obj, {
										sender: senderAddress,
										receiver: receiverAddress,
										amount: tokenAmount,
										contractName,
										userChoice,
										type: "contracttransfer",
									});
									latestTxArray.push(obj);
									break;
								}
							case 'tokenIncorporation':
								// token incorporation
								// smart contract incorporation
								obj = Object.assign({}, obj, {
									incAddress: senderAddress,
									supply: tokenAmount,
									type: "tokenincorp",
								});
								latestTxArray.push(obj);
								break;
							case 'smartContractIncorporation':
								// smart contract incorporation
								// todo : add checks to determine obj for different types of smart contract incorporation
								switch (subtype) {
									case 'tokenswap':
										obj = Object.assign({}, obj, {
											contractName,
											incAddress: contractAddress,
											contractType,
											type: "contractincorp",
											sellingToken: selling_token,
											acceptingToken: accepting_token,
											price,
										});
										delete obj["token"];
										break;
									default:
										obj = Object.assign({}, obj, {
											contractName,
											incAddress: contractAddress,
											contractType,
											expiration: expiryTime,
											participationFees: contractAmount,
											availableChoices: "",
											type: "contractincorp",
											minAmount: minimumsubscriptionamount,
											maxAmount: maximumsubscriptionamount,
										});
										break;
								}
								latestTxArray.push(obj);
								break;
							case 'nftIncorporation':
								// nft incorporation
								obj = Object.assign({}, obj, {
									incAddress: senderAddress,
									supply: tokenAmount,
									type: "nftincorp",
									nftHash
								});
								latestTxArray.push(obj);
								break;
							case 'smartContractDeposit':
								// smart contract deposit
								obj = Object.assign({}, obj, {
									contractName,
									contractAddress,
									contractType,
									amount: depositAmount,
									type: "contractdeposit",
									sender: senderAddress,
									receiver: receiverAddress,
								});
								latestTxArray.push(obj);
								break;
						}

					} else {
						// transaction is a FLO Smart Contract Committee trigger

						obj = Object.assign({}, obj, {
							hash: txid,
							blockHeight,
							contractName,
							contractAddress: receiverAddress,
							winningChoice: triggerCondition,
							committeeAddress: senderAddress,
							type: 'contracttrigger'
						});
						latestTxArray.push(obj);
					}
				} else {
					obj = Object.assign({}, obj, {
						transactionTrigger,
						contractName,
						contractAddress,
						onChain: false,
						type: 'offChainTransfer',
						senderAddress,
						receiverAddress,
						tokenAmount,
						tokenIdentification,
						time
					});
					latestTxArray.push(obj);
				}
			})

			return latestTxArray;
		}

		async function getAllBlocks(number) {
			const allBlocks = await fetchJson(`${floGlobals.tokenApiUrl}/api/v2/latestBlockDetails${number ? `?limit=${number}` : ''}`)
			return Object.values(allBlocks.latestBlocks).sort((a, b) => b.height - a.height)
		}

		async function getAllTxs() {
			const allTxs = await fetchJson(`${floGlobals.tokenApiUrl}/api/v2/latestTransactionDetails?limit=200`)
			return allTxs.latestTransactions
		}

		async function getAddressInfo(floAddress) {
			const addressInfo = await fetchJson(`${floGlobals.tokenApiUrl}/api/v2/floAddressInfo/${floAddress}`)
			return addressInfo.floAddressBalances
		}

		async function getAddressBalance(floAddress) {
			return await fetchJson(`${floGlobals.floApiUrl}/api/addr/${floAddress}/balance`)
		}

		async function getAddressTxs(floAddress) {
			const transactions = await fetchJson(`${floGlobals.tokenApiUrl}/api/v2/floAddressTransactions/${floAddress}`)
			return transactions.transactions
		}

		async function getTxInfo(thisTx) {
			try {
				const transaction = await fetchJson(`${floGlobals.tokenApiUrl}/api/v2/transactionDetails/${thisTx}`)
				console.log(transaction)
				if (transaction.result === 'error')
					return [false, transaction.description]
				let {
					floData,
					tokenAmount,
					tokenIdentification,
					type,
					nftHash,
					blockheight,
					vin,
					vout,
					confirmations,
					transferType,
					senderAddress,
					receiverAddress,
					txid,
					onChain,
					subTransactions,
					time
				} = transaction;
				if (type == 'smartContractPays') {
					tokenAmount = '-'
				}
				return [
					true, {
						type: `${transferType || ''} ${type}`,
						name: tokenIdentification,
						blockHeight: blockheight,
						amount: tokenAmount,
						sender: senderAddress,
						receiver: receiverAddress,
						floData,
						hash: txid,
						confirmations,
						nftHash,
						onChain,
						subTransactions,
						time
					}
				]
			}
			catch (err) {
				console.error(err)
			}
		}


		function returnHexNumber(s) {
			var regExp = /^[-+]?[0-9A-Fa-f]+\.?[0-9A-Fa-f]*?$/;
			return (typeof s === 'string' && regExp.test(s));
		}

		function isInt(n) {
			return Number(n) === n && n % 1 === 0;
		}

		function isFloat(n) {
			return Number(n) === n && n % 1 !== 0;
		}

		function splitContractNameAddress(text) {
			const index = text.lastIndexOf('-');
			return {
				name: text.substring(0, index),
				address: text.substring(index + 1)
			};
		}

		function categorizeText(text) {
			return new Promise((resolve, reject) => {
				// check if text have only numbers
				if (/^\d+$/.test(text)) {
					//console.log('this is a block number');
					location.href = `#/block/${text}`
					resolve('block')
				} else if (text.length == 34 && floCrypto.validateFloID(text)) {
					//console.log('data entered is a FLO address');
					location.href = `#/address/${text}`
					resolve('address')
				} else if (floGlobals.tokenList.includes(text.toLowerCase())) {
					//console.log('data entered is a token name');
					location.href = `#/token/${text}`
					resolve('token')
				} else if (floGlobals.smartContractNameAddressList.has(text)) {
					location.href = `#/contract/${text}`
					resolve('contract')
				} else if (text.length == 64 && returnHexNumber(text)) {
					fetchJson(`${floGlobals.tokenApiUrl}/api/v2/categoriseString/` + text)
						.then(function (myJson) {
							console.log(`${floGlobals.tokenApiUrl}/api/v2/categoriseString/` + text)
							if (myJson['type'] == 'transaction') {
								//console.log('data entered is a transaction hash');
								location.href = `#/transaction/${text}`
							} else if (myJson['type'] == 'block') {
								// console.log('data entered is a block hash');
								location.href = `#/block/${text}`
							} else {
								renderElem(getRef("page_container"), html`${render.errorPage('The entered text is not a part of the token system')}`);
							}
							resolve()
						}).catch(err => {
							console.error(err)
							resolve()
						})

				} else {
					renderElem(getRef("page_container"), html`${render.errorPage('Invalid search query')}`);
				}
			})
		}

		async function processNavbarSearch() {
			const query = getRef('main_search_field').value.trim();
			try {
				await getAllSuggestions();
				if (query === '') return
				await categorizeText(query)
				getRef('main_search_field').value = ''
				renderElem(getRef('suggestions'), html``)
			} catch (err) {
				console.error(err)
			}
		}

		async function getAllSuggestions() {
			window.allSuggestions = [];
			let { tokens, smartContracts } = await fetchJson(`${floGlobals.tokenApiUrl}/api/v2/tokenSmartContractList`);
			floGlobals.tokenList = tokens;
			floGlobals.smartContractList = smartContracts;
			floGlobals.smartContractNameAddressList = new Set();
			floGlobals.smartContractList.forEach(contract => {
				allSuggestions.push(`${contract.contractName}-${contract.contractAddress}`);
				floGlobals.smartContractNameAddressList.add(`${contract.contractName}-${contract.contractAddress}`);
			})
			allSuggestions = allSuggestions.concat(tokens);
			window.flexSearchIndex = new FlexSearch.Index({
				tokenize: "reverse",
				suggest: true
			});

			allSuggestions.forEach((suggestion, index) => {
				flexSearchIndex.add(index, suggestion);
			})
		}
	</script>
</body>

</html>
